function [NewSchur,U] = SchurUpdate(OldSchur,E,X0,LS,hyp)
% Given the old line searches and the old (rank M) Schur complement of the
% belief generated by those linesearches, a new linesearch of m observations can
% be used to efficiently update to the new (rank M+m) complement.
%
% This code should be combined with Projection(x,LS,hyp) to get the
% projection of the belief.
%
% The new Schur complement (NSC) relates to the old complement (OSC) as
%         -----------
%  NSC =  | OSC   R |  
%         |  R'   T |
%         -----------
%
% where T contains univariate double integrals, while R consists of bivariate
% integrals, and has itself block structure: R = [r1 r2 r3 ...]', with each ri
% consisting of the bivariate integrals for one linesearch pair (calculations
% have an overhead of O(N^2) for each block ri, but afterwards are only O(1) 
% for each element in the block).
%
% E   : N x i  unit-length vectors for the i line searches
% X0  : N x i  starting positions for line searches
% LS{i}.a : 1D locations of the evaluation points relative to the starting point,
%            as measured along E(:,i) (mt x 1)
% LS{i}.F : evaluated function values (not used by the optimizer, for now)1 x mt
% LS{i}.dF: evaluated gradients (not used here, but used in outer loop) (N x mt)
%
% This returns a normalised form  NSC = NSC0 .* (U * U') where 
% U = sqrt( 1 ./ diag(NSC0)); This helps tremendously with
% numerical stability.
%
% Philipp Hennig, January 2012

%% unpack
sf2  = hyp.sf2; ell = hyp.ell; V = hyp.V;        % unpack kernel hyperparameters
ell2 = ell .* ell;
[N,i]= size(E); %#ok<ASGLU>
En   = bsxfun(@rdivide,E,ell); Xn = bsxfun(@rdivide,X0,ell);
EE   = En' * En; % i x i

isLimitedMemory = min(size(V))==1 && ~all(size(V)==1);

%% construct covariance between elements of the new linesearch
up   = LS{i}.a; dn = LS{i}.b; %[0; LS{i}.a(1:end-1)];
upup = bsxfun(@minus,up,up');
dndn = bsxfun(@minus,dn,dn');
updn = bsxfun(@minus,up,dn');

if isLimitedMemory
  eVe = E(:, i)' * (V .* E(:, i));
else
  eVe  = E(:,i)' * V * E(:,i);                               % element covariance
end
sig2 = 1 ./ EE(i,i);                                % function value covariance
l222 = sqrt(2 * sig2);

t1   = sqrt(pi/(2*sig2)) * (upup .* erf(upup /l222)) + exp(-upup   .^2 / (2*sig2));
t2   = sqrt(pi/(2*sig2)) * (updn .* erf(updn /l222)) + exp(-updn   .^2 / (2*sig2));
t3   = sqrt(pi/(2*sig2)) * (updn'.* erf(updn'/l222)) + exp(-(updn').^2 / (2*sig2));
t4   = sqrt(pi/(2*sig2)) * (dndn .* erf(dndn /l222)) + exp(-dndn   .^2 / (2*sig2));

T    = eVe * sf2 * sig2 * ( -t1 + t2 + t3 - t4);
T    = 0.5* (T + T'); % symmetrize. t2+t3 is only symmetric up to machine error
%% construct covariance between this linesearch and others
MT   = 0; for j = 1:i-1; MT = MT + length(LS{j}.a); end

R = zeros(MT,size(T,1));
h0 = 0;
for j = 1:i-1                                            % for each line search
    % pre-computations for speed
    detA = EE(i,i) * EE(j,j) - EE(i,j) * EE(j,i);                        % O(1)
    Ai   = [EE(i,i), EE(i,j); EE(j,i), EE(j,j)] ./ detA;                 % O(1)
    d    = Xn(:,j) - Xn(:,i); dd = d' * d;                             % O(N^2)
    ejd = En(:,j)' * d; eid = En(:,i)' * d;                            % O(N^2)
    rho  = EE(i,j) / sqrt(EE(i,i) * EE(j,j));                            % O(1)
    if isLimitedMemory
      prefactor = sf2 * 2 * pi * E(:,i)' * (V .* E(:,j)) / sqrt(detA);   % O(1)
    else
      prefactor = sf2 * 2 * pi * E(:,i)' * V * E(:,j) / sqrt(detA);      % O(1)
    end
    upj = LS{j}.a; dnj = LS{j}.b; %[0; LS{j}.a(1:end-1)];
    for h = 1 : length(LS{j}.a)                   % for each ls-location in ls j
        for k = 1 : length(LS{i}.a)               % for each ls-loc in new ls
            b = [dnj(h) * EE(j,j) + ejd - dn(k) * EE(i,j);...
                 dn(k) * EE(i,i) - eid - dnj(h) * EE(i,j)];
            c = dnj(h) * dnj(h) * EE(j,j) + dn(k) * dn(k) * EE(i,i) + dd ...
                + 2*(d' * (dnj(h)*En(:,j)-dn(k)*En(:,i)) -dnj(h)*dn(k)*EE(i,j));
            et= exp(-0.5 * (c-b' * Ai * b));
            ui= sqrt(1-rho*rho) * diag(sqrt([EE(j,j),EE(i,i)])) * Ai * b;
            uf= (sqrt(1-rho*rho) * diag(sqrt([EE(j,j),EE(i,i)])) ...
                * [upj(h)-dnj(h); up(k)-dn(k)]) + ui;
            R(h0 + h,k) = prefactor * et * ... 
                (BivariateNormalCDF(uf(1),uf(2),rho) ...
                -BivariateNormalCDF(uf(1),ui(2),rho) ...
                -BivariateNormalCDF(ui(1),uf(2),rho) ...
                +BivariateNormalCDF(ui(1),ui(2),rho));
        end    
    end
    h0 = h0 + length(LS{j}.a);
end

%% update the Schur complement
NewSchur = [OldSchur, R; R', T];

%U = ones(size(NewSchur,1),1); 
U = sqrt(diag(NewSchur));
NewSchur = NewSchur ./ (U * U');
